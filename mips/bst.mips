.eqv	INT_MIN	0x80000000
.eqv	NULL	0

.data
invalid_tree:	.asciiz	"The tree is invalid"
valid_tree:	.asciiz "The tree is valid"

.text

		jal	build		# v0 = root node
		
		move 	$a0, $v0
		jal	check		# v0 = is tree valid
		
		beqz	$v0, print_invalid
		la	$a0, valid_tree
		li	$v0, 4		# print string
		syscall	
		j	program_end
print_invalid:			
		la	$a0, invalid_tree
		li	$v0, 4		# print string
		syscall
		
program_end:	li	$v0, 10
		syscall
	
	
#################################################################################
# new_node: Create new tree node
# $a0: node data to init
# $a1: address of the parent node (may be NULL)
# $v0: address of the allocated node
.text
new_node:	move	$t0, $a0	# save node data into $t0
		
		li	$v0, 9		# sbrk
		li	$a0, 16		# allocate space for 4 words
		syscall			# $v0 will contain the address of the allocated memory
		
		sw	$t0, 0($v0)	# node->data = data
		sw	$zero, 4($v0)	# node->left = NULL
		sw	$zero, 8($v0)	# node->right = NULL
		sw	$a1, 12($v0)	# node->parent = parent
		
		jr	$ra		# v0 will still contain the address we're supposed to return
#################################################################################


#################################################################################
# insert
# $a0: address of node
# $a1: data to insert
# returns nothing
.text
insert:		sub	$sp, $sp, 16	# space for 4 vars on stack
		sw	$ra, 0($sp)	# save return address
		sw	$s0, 4($sp)	# save saved registers
		sw	$s1, 8($sp)
		sw	$s2, 12($sp)
		
		move	$s0, $a0	# s0 = address of node
		move	$s1, $a1	# s1 = data
		lw	$s2, 0($s0)	# s2 = node->data
		
		bgt	$s2, $s1, insert_left	# node->data > data ?
		lw	$t0, 8($s0)	# t0 = node->right
		bnez	$t0, insert_right_rec
		move	$a0, $s1	# a0 = data
		move	$a1, $s0	# a1 = node 
		jal	new_node	# v0 = new_node(data, node)
		sw	$v0, 8($s0)	# node->right = v0
		j	insert_end
insert_right_rec:	move	$a0, $t0	# a0 = node->right
		move	$a1, $s1	# a1 = data
		jal	insert		# insert(node->right, data)
		j	insert_end
insert_left:	lw	$t0, 4($s0)	# t0 = node->left
		bnez	$t0, insert_left_rec
		move	$a0, $s1	# a0 = data
		move	$a1, $s0	# a1 = node 
		jal	new_node	# v0 = new_node(data, node)		
		sw	$v0, 4($s0)	# node->left = v0
		j insert_end
insert_left_rec:	move	$a0, $t0	# a0 = node->left
		move	$a1, $s1	# a1 = data
		jal	insert		# insert(node->left, data)		

insert_end:	lw	$s2, 12($sp)	# restore saved registers
		lw	$s1, 8($sp)		
		lw	$s0, 4($sp)
		lw	$ra, 0($sp)	# restore return address
		add	$sp, $sp, 16	# pop everything from stack frame		
		jr	$ra		
#################################################################################


#################################################################################
# check: Checks if tree is a valid BST
# $a0: root node address
# $v0: 1 if valid, 0 otherwise
.text
check:	
		li	$v0, 1		# valid yay
		
		jr	$ra
#################################################################################


#################################################################################
# build: Builds a BST given an array of integers terminated by INT_MIN
# $a0: address of array
# $v0: address of the root node of the new BST
.data
source:		.word	1, 6, 7, 4, 3, 6, 8, 2, 9, 12, -3, 4, 54, 35, 5, INT_MIN
.text
build:		sub	$sp, $sp, 12
		sw	$ra, 0($sp)
		sw	$s0, 4($sp)
		sw	$s1, 8($sp)
		
		lw	$a0, source		# a0 = first element of source
		move	$a1, $zero
		jal	new_node		# v0 = new_node(source[0], NULL)
		
		move	$s0, $v0		# s0 = address of root node
			
		li	$s2, 0			# i is s2
build_loop:	add	$s2, $s2, 4		# i++
		lw	$t1, source($s2)	# t1 = source[s2]
		beq	$t1, INT_MIN, build_endloop
		
		move	$a0, $s0
		move	$a1, $t1
		jal	insert			# insert(node, source[i])
		
		j	build_loop	
		
build_endloop:	move	$v0, $s0		# return root node
		
		lw	$s1, 8($sp)
		lw	$s0, 4($sp)
		lw	$ra, 0($sp)
		add	$sp, $sp, 12
		jr	$ra
#################################################################################




